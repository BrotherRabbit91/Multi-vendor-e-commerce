<?php

namespace App\Http\Controllers\API;

use App\Http\Controllers\Controller;
use Illuminate\Http\Request;

class APIController extends Controller
{
    // Check API Endpoints/URLs/links in "api.php" file (NOT "web.php" file!)
    // Note: When working with APIs (like working in APIController.php), everything returned must be in JSON format.
    // https://www.youtube.com/watch?v=mcSoGDSrdsU&list=PLLUtELdNs2ZaPSOuYoosmSj5TUuXjl_uu&index=2
    // Shiprocket API Documentation: https://apidocs.shiprocket.in/



    // Push our 'ecom9' website orders (from our `orders` database table) to Shiprocket    // Shiprocket API Documentation: https://apidocs.shiprocket.in/    // https://www.youtube.com/watch?v=mcSoGDSrdsU&list=PLLUtELdNs2ZaPSOuYoosmSj5TUuXjl_uu&index=2
    public function pushOrder($id) { // This route/URL/link is: GET http://127.0.0.1:8000/api/push-order/3    // Route Parameters: Required Parameters: https://laravel.com/docs/9.x/routing#required-parameters
        // Get the Order from `orders` table and its order Details from `orders_products` table (using the 'order_items' Relationship)
        $getResults = \App\Models\Order::pushOrder($id);


        return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
            'status'  => $getResults['status'],
            'message' => $getResults['message']
        ]);
    }
















    // Our ecom9 Website API: https://www.youtube.com/playlist?list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE
    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc.
    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
    // Note: When sending/submitting an HTTP Request to an API, whether GET, PUT, PATCH, DELETE requests, you can send your Query String Parameters with your request using THREE ways: first way: is the normal/regular way by sending your Query String Parameters in the request "Body", like for example, JSON data (e.g.    {"id": 10, "name": "John", "age": 10}    ), the second way: Although the used HTTP Method/Verb might NOT be GET, and you may be using a PUT/PATCH/DELETE request, you can send your Query String Parameters in the URL (e.g. www.example.com?id=10&name=John&age=24), and you can retrieve them in the backend using the $_GET superglobal (IMPORTANT: Despite the fact that the used HTTP Method/Verb is NOT "GET"), and of course no doubt, you can use this way with the GET HTTP Requests, the third way: use the "Params" tab in Postman to send your Query String Parameters Key/Value pairs in the dedicated fields in Postman (e.g. in Postman "Key" field write in "id", and in Postman "Value" field, write in "10" ).
    // Note: The relation between the HTTP Status Codes of the HTTP Responses & the HTTP Methods/Verbs used in the HTTP Requests when sending back an HTTP Response for an HTTP Request: If you're building your API, for GET requests, send back 200 OK HTTP Status Code with your HTTP Response, and for POST requests, send back 201 Created HTTP Status Code with your HTTP Response, and for PUT/PATCH requests, send back 202 Accepted HTTP Status Code with your HTTP Response, and for DELETE requests, send back 204 No Content, 202 Accepted or 200 OK HTTP Status Code with your HTTP Response. Check 8:40 in https://www.youtube.com/watch?v=Yg1715nXueU&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=11
    // Note: Access Tokens (e.g. JWT, regular tokens, â€¦) role in APIs act exactly the same as 'browser Session' (in Web Development world where the 'client' is the 'browser'), as both Access Tokens and Sessions are sent from the client to the server with EVERY HTTP Request. But, 'browser Sessions' are available only in 'browsers', which is not the case with APIs and Mobile/Android Applications for examlple. So, Access Tokens are used instead of 'browser Sessions' in clients that don't have Sessions. (i.e. Access Tokens are used in APIs and mobile phones as there is no browser Session available!)
    // Note: The Registration (for the first time), Validation, Authentication/Login, browser Session and Logout Processes Workflow (Story) in Web Development: In Web Development world, the client is the 'browser', and where there is a browser Session. So, Registration for the first time Process: Everything starts with a user registers a new account with their email and password, we validate those submitted data (we make sure the email is a valid email, and it doesn't already exist in our database table, and it's 'required' i.e. not optional), then we save those validated data in our database table (for later authentication/login), and if all this were OK, we generate a new Session on the server for this specific user, which is sent to the client (the client is the browser in this case) as a browser Cookie (which holds a Session ID). This Cookie/Session ID is sent with every subsequent HTTP Request that the user makes from the client (the broswer in this case), this Session ID tells the server that this is the user that is logged in (the server identifies the user through that Session ID). Protected Routes: Every page in the website which requires the user to be authenticated/logged-in (such as Profile page, Orders page, ...) must check if the user sending the HTTP Request exists on the server's Session, to allow the user to continue sending HTTP Requests to access those Protected Routes on the website. We expire this session when the user logs out, so if the user makes a subsequent request after logging out, the server doesn't respond with an HTTP Response because the Session Cookie that the browser sends to the server has been deleted from the server when the user logged out. Authentication/Login Process: When the user logs in to their account, we do validation on their submitted data (we check if the submitted email already exists in our database table or not, then we verify that the submitted password (the hashed one) matches the hashed password in our database table), if all this were OK, we generate a new Session on the server, and the client (which is the browser in this case) stores a new Session Cookie (received from the server) that has a Session ID. This Session Cookie is sent by the client (the browser in this case) with EVERY HTTP Request the client (i.e. the broswer in this case) makes in order for the server to identify the logged-in user by comparing the Session ID of the Cookie sent from the client (i.e. browser) with the Session ID stored on the server. When the user logs out, the Session gets expired on the server (deleted), and the client's (i.e the browser in this case) browser's Session Cookie no longer works, so the user must login again in order for the server to generate a new Session for them.
    // Note: The Registration, Validation, Authentication/Login, Access Tokens (act exactly as 'browser Sessions' because of the fact that there is no browser here in APIs!) and Logout Processes Workflow (Story) in APIs: In APIs field, we try to simulate/imitate everything that happens in the Web Development world where the 'client' is the 'browser' and where there is a 'browser Session', but with APIs (as with the case of Mobile/Android applications, for example), there is no browser nor there is no Session (that's why we use Access Tokens instead of 'browser Sessions'). So, Registration for the first time Process: Everything starts with a user registers a new account with their email and password, we validate those submitted data (we make sure the email is a valid email, and it doesn't already exist in our database table, and it's 'required' i.e. not optional), and if submitted data passes our validation, we generate a new Access Token for this specific user, then we save those validated data and the newly generated Access Token in our database table (for later authentication/login), then we send the Access Token to the client as a JSON HTTP Response to their HTTP Request. This Access Token must be sent by the user an 'Authorization' HTTP Header with EVERY subsequent HTTP Request (JUST LIKE THE SESSION IN CASE OF BROWSERS (in Web Development)) that the user makes from their client, this Access Token gets compared on the server with that specific user's Access Token which is saved in our database table to make sure this is the user! (to keep them logged-in JUST LIKE THE CASE OF SESSION IN BROWSERS). Protected Routes: All your API endpoints (all your routes methods in APIController) in your API must check if the 'Authorization' HTTP Header (i.e. Access Token) is provided/sent by the client to the server (just like Protected Routes in Web Development (Laravel) where every page in a website that requires the user to be authenticated/logged-in (such as Profile page, Orders page, ...) checks if there is a user stored on the server's Session or not, to allow the user to continue sending their HTTP Requests to access those Protected Routes) (except for the Registration API endpoint and the Login API endpoint, those two API endpoins don't check the Access Token because they are already generating one) and check if that Access Token exists or not in your database table (this is done to not allow the user to further use/access your API endpoints unless they have an Access Token and they have the correct one!). We expire this Access Token when the user logs out by deleting it from the database table when the user logs out, so if the user makes a subsequent request after logging out, the server doesn't respond with an HTTP Response (we just send a "You're logged out!" JSON HTTP Response message) because their Access Token that user's client sends to the server has been deleted from the database table when the user logged out. Authentication/Login: When the user logs in to their account, we do validation on their submitted data (we check if the submitted email already exists in our database table or not, then we verify that the submitted password (the hashed one) matches the hashed password in our database table), if all this were OK, we generate a new Access Token for the user, then we replace/update the user's old Access Token with the new one in the database table, and then we send the user the new Access Token in a JSON HTTP Response. This Access Token must be sent by the client with EVERY HTTP Request the client makes in order for the server to identify the logged-in user. When the user logs out, we expire the Access Token by deleting it from the database table, and the client's current Access Token no longer works, so the user must login again in order for the server to generate a new Access Token for them and update the database table with it.
    // Note: As a convention of how APIs work, the 'Authorization' HTTP Header is sent with the HTTP Request as a "Bearer Token" (in "Headers" tab in Postman) in the following form:     "Bearer xxxxxxxxxxxxxxxxxxxxxxxxxxxx"     where 'xxxxxxxxx' is the Access Token. Ex:     "Bearer L8qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyOg"


    // Get ALL users    Or    Get a SINGLE user (GET)    (depending on if the {id?} Optional Paramter specified or not in the API Endpoint route)    // API Endpoint:    GET http://127.0.0.1:8000/api/users Or GET http://127.0.0.1:8000/api/users/37    // User must send an "Authorization" HTTP Header with all their HTTP Requests with this value (Bearer Token (JWT)): "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFtaXQgR3VwdGEiLCJpYXQiOjE1MTYyMzkwMjJ9.cNrgi6Sso9wvs4GlJmFnA4IqJY4o2QEcKXgshJTjfNg"    // https://www.youtube.com/watch?v=ItB3CjQlidk&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=2
    public function getUsers(Request $request, $id = null) { // {id?}    Route Parameters: Optional Parameters: https://laravel.com/docs/9.x/routing#parameters-optional-parameters
        if ($request->isMethod('get')) { // Check if the incoming HTTP Request Method/Verb is 'GET'
            // $userData = $request->input();
            // $userData = $request->all();
            // dd($userData);
            /* echo '<pre>', var_dump($userData), '</pre>';
            exit; */



            // Simple Authentication    // https://www.youtube.com/watch?v=JIoEck2kPpA&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=13
            $header = $request->header('Authorization'); // Get the 'Authorization' HTTP Header sent from the user's client to the server with their HTTP Request    // Request Headers: https://laravel.com/docs/9.x/requests#request-headers
            // dd($header);

            if (empty($header)) { // If the user didn't send the "Authorization" HTTP Header (i.e. the Bearer Access Token) with their HTTP Request (if the user didn't provide the 'Authorization' Header) (Note: If the user didn't include the 'Authorization' Header at all, NOT gave a wrong value for it!)
                $message = 'Authorization Header (Access Token) is Missing!';

                return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                    'status'  => false,
                    'message' => $message
                ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

            // } elseif ($header != '123456789') { // JWT token generated by (we wrote in "Amit Gupta" to generate this token in the website): https://jwt.io/    // User must send an "Authorization" HTTP Header with all their HTTP Requests with this value (Bearer Token (JWT)): "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFtaXQgR3VwdGEiLCJpYXQiOjE1MTYyMzkwMjJ9.cNrgi6Sso9wvs4GlJmFnA4IqJY4o2QEcKXgshJTjfNg"
            } elseif ($header != 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFtaXQgR3VwdGEiLCJpYXQiOjE1MTYyMzkwMjJ9.cNrgi6Sso9wvs4GlJmFnA4IqJY4o2QEcKXgshJTjfNg') { // JWT token generated by (we wrote in "Amit Gupta" to generate this token in the website): https://jwt.io/    // User must send an "Authorization" HTTP Header with all their HTTP Requests with this value (Bearer Token (JWT)): "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFtaXQgR3VwdGEiLCJpYXQiOjE1MTYyMzkwMjJ9.cNrgi6Sso9wvs4GlJmFnA4IqJY4o2QEcKXgshJTjfNg"
                $message = 'Authorization Header value is Incorrect!';

                return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                    'status'  => false,
                    'message' => $message
                ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
            }



            if (empty($id)) { // if the {id?} Optional Paramter is not specified in the API Endpoint URL, get ALL users
                $users = \App\Models\User::get();
                // dd($users);
                // echo '<pre>', var_dump($users), '</pre>';
                // exit;
            } else {  // if the {id?} Optional Paramter is specified in the API Endpoint URL, get a SINGLE user
                $users = \App\Models\User::find($id);
                // dd($users);
                // echo '<pre>', var_dump($users), '</pre>';
                // exit;
            }


            // Send back the newly submitted user data of the successful operation to the user again! (Note: This a well-known convention of APIs to send back the successful accepted data!)    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
            // return $user;          // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!
            return response()->json([ // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'users'   => $users
            ], 200); // 200 HTTP Status Code: OK    // With GET requests, 200 OK HTTP Status Code is sent with the HTTP Response    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

        } else { // if the user is using the wrong dedicated HTTP Request Method/Verb for their request (i.e. User has used an HTTP Request Method/Verb other than 'GET')
            $message = 'You are using an incorrect HTTP Method/Verb to access this route/endpoint in our API!';

            return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'status'  => false,
                'message' => $message
            ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
        }
    }

    // Create a Single user (POST)    // API Endpoint:    POST http://127.0.0.1:8000/api/add-user    // 'name', 'email' and 'password' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )     // https://www.youtube.com/watch?v=_2OnU1mrOCc&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=3
    public function addUser(Request $request) {
        if ($request->isMethod('post')) { // Check if the incoming HTTP Request Method/Verb is 'POST'
            $userData = $request->input();
            // $userData = $request->all();
            // dd($userData);
            /* echo '<pre>', var_dump($userData), '</pre>';
            exit; */


            /*
            // Validation (Simple/Regular PHP Validation)    // https://www.youtube.com/watch?v=2re_3ResXVA&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=5
            // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request! .    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

            // Check if there are empty submitted fields
            if (empty($userData['name']) || empty($userData['email']) || empty($userData['password'])) {
                $error_message = 'Please enter complete user details!';

                // return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                //     'status'  => false,
                //     'message' => $error_message
                // ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
            }

            // Make sure the submitted email is a valid email
            if (!filter_var($userData['email'], FILTER_VALIDATE_EMAIL)) { // https://www.w3schools.com/php/filter_validate_email.asp
                $error_message = 'Please enter a valid email!';

                // return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                //     'status'  => false,
                //     'message' => $error_message
                // ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
            }

            // Check if the submitted email already exists in our `users` database table
            $userCount = \App\Models\User::where('email', $userData['email'])->count();
            if ($userCount > 0) {
                $error_message = 'Email already exists!';

                // return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                //     'status'  => false,
                //     'message' => $error_message
                // ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!
            }

            // Show ONE COMMON error message for all Validations if an error/errors exist
            if (isset($error_message) && !empty($error_message)) {
                return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                    'status'  => false,
                    'message' => $error_message
                ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

            
            }
            */

            // Validation (Laravel Validation)    // https://www.youtube.com/watch?v=rWpHD4I1j8Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=8
            // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request! .    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
            // Manually Creating Validators: https://laravel.com/docs/9.x/validation#manually-creating-validators
            $rules = [
                // Fields/Column Names
                'name'     => 'required|regex:/^[\pL\s\-]+$/u', // regex:pattern: https://laravel.com/docs/9.x/validation#rule-regex
                'email'    => 'required|email|unique:users', // 'unique' validation rule in `users` datbase table    // unique:table,column: https://laravel.com/docs/9.x/validation#rule-unique
                'password' => 'required'
            ];

            // Customizing Laravel's default error messages for every [Field with Validation Rule] e.g. the 'required' Validation Rule for the 'name' field    // Customizing The Error Messages: https://laravel.com/docs/9.x/validation#manual-customizing-the-error-messages
            $customMessages = [
                // The SAME last Fields (inside $rules array)
                'name.required'     => 'Your Name (field) is required',

                'email.required'    => 'Your email (field) is required',
                'email.email'       => 'Your email (field) must be a Valid email',
                'email.unique'      => 'Your email already exists in our database!',

                'password.required' => 'Your password (field) is required'
            ];

            // $validator = \Illuminate\Support\Facades\Validator::make($userData, $rules);
            $validator = \Illuminate\Support\Facades\Validator::make($userData, $rules, $customMessages);

            // dd($validator->errors());   // is THE SAME AS:    dd($validator->messages());    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
            // dd($validator->messages()); // is THE SAME AS:    dd($validator->errors());      // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages

            if ($validator->fails()) {
                return response()->json($validator->errors(), 422);       // This is THE SAME AS the next line of code    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses     // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
                // return response()->json($validator->messages(), 422);  // This is THE SAME AS the last line of code    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses     // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
            }



            // Add/Save the submitted new user data in `users` table ('name', 'email', 'password' fields must be submitted in Postman!)
            $user = new \App\Models\User;
            $user->name     = $userData['name'];
            $user->email    = $userData['email'];
            $user->password = bcrypt($userData['password']); // Hash the password before storing it in the database table
            $user->save();


            // Send back the newly submitted user data of the successful operation to the user again! (Note: This a well-known convention of APIs to send back the successful accepted data!)    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
            // return $user;          // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!
            return response()->json([ // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'message' => 'User added successfully!',
                'user'    => $user
            ], 201); // 201 HTTP Status Code: Created    // With POST requests, 201 Created HTTP Status Code is sent with the HTTP Response    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

        } else { // if the user is using the wrong dedicated HTTP Request Method/Verb for their request (i.e. User has used an HTTP Request Method/Verb other than 'POST')
            $message = 'You are using an incorrect HTTP Method/Verb to access this route/endpoint in our API!';

            return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'status'  => false,
                'message' => $message
            ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
        }
    }

    // Create Multiple users (also works for Create a Single user) (POST)    // API Endpoint:    POST http://127.0.0.1:8000/api/add-multiple-users    // Note: In Postman, JSON data are submitted using Curly Braces {} and a "users" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'name', 'email' and 'password' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )     // https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4
    public function addMultipleUsers(Request $request) {
        if ($request->isMethod('post')) { // Check if the incoming HTTP Request Method/Verb is 'POST'
            $userData = $request->input();
            // $userData = $request->all();
            // dd($userData);
            // dd($userData['users']);
            /* echo '<pre>', var_dump($userData), '</pre>';
            echo '<pre>', var_dump($userData['users']), '</pre>';
            exit; */



            // Validation (Laravel Validation)    // https://www.youtube.com/watch?v=UWnn9FOgKck&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=8
            // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request! .    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
            // Manually Creating Validators: https://laravel.com/docs/9.x/validation#manually-creating-validators
            // Important Note: Here, this situation is different! Because JSON data come in as bulk/multiple JSON data/objects! So, we have to modify our validation Rules syntax a litte!    // Important Note (Validation Rules syntax for incoming/submitted bulk/multiple JSON data/objects and their Custom Messages  i.e.  This is called "Validating Nested Array Input": https://laravel.com/docs/9.x/validation#validating-nested-array-input): If you want to validate (do Validation) incoming data, which for example come as JSON data submitted to your API, and those data come as bulk/multiple JSON data/objects which are wrapped inside a JSON Wrapping Object, you can write your $rules array like:     $rules = [ 'users.*.name' => 'requried' ];     where 'users' is the JSON Wrapping Object, and * (asterisk) is the array indexes (e.g. 0, 1, 2, ...). Check 2:24 in https://www.youtube.com/watch?v=UWnn9FOgKck&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=8    // Validating Nested Array Input: https://laravel.com/docs/9.x/validation#validating-nested-array-input
            $rules = [
                // Fields/Column Names
                // Validating Nested Array Input: https://laravel.com/docs/9.x/validation#validating-nested-array-input
                'users.*.name'     => 'required|regex:/^[\pL\s\-]+$/u', // Note: Submitted data is bulk/mulple JSON data/objects wrapped in a 'users' JSON Wrapping Object, and '*' (asterisk) denotes the array keys/indexes (e.g. 0, 1, 2, ...)    // Validating Nested Array Input: https://laravel.com/docs/9.x/validation#validating-nested-array-input
                'users.*.email'    => 'required|email|unique:users',    // Note: Submitted data is bulk/mulple JSON data/objects wrapped in a 'users' JSON Wrapping Object, and '*' (asterisk) denotes the array keys/indexes (e.g. 0, 1, 2, ...)    // Validating Nested Array Input: https://laravel.com/docs/9.x/validation#validating-nested-array-input
                'users.*.password' => 'required'                        // Note: Submitted data is bulk/mulple JSON data/objects wrapped in a 'users' JSON Wrapping Object, and '*' (asterisk) denotes the array keys/indexes (e.g. 0, 1, 2, ...)    // Validating Nested Array Input: https://laravel.com/docs/9.x/validation#validating-nested-array-input
            ];

            // Customizing Laravel's default error messages for every [Field with Validation Rule] e.g. the 'required' Validation Rule for the 'name' field    // Customizing The Error Messages: https://laravel.com/docs/9.x/validation#manual-customizing-the-error-messages
            $customMessages = [
                // The SAME last Fields (inside $rules array)
                'users.*.name.required'     => 'Your Name (field) is required',              // Note: Submitted data is bulk/mulple JSON data/objects wrapped in a 'users' JSON Wrapping Object, and '*' (asterisk) denotes the array keys/indexes (e.g. 0, 1, 2, ...)    // Validating Nested Array Input: https://laravel.com/docs/9.x/validation#validating-nested-array-input

                'users.*.email.required'    => 'Your email (field) is required',             // Note: Submitted data is bulk/mulple JSON data/objects wrapped in a 'users' JSON Wrapping Object, and '*' (asterisk) denotes the array keys/indexes (e.g. 0, 1, 2, ...)    // Validating Nested Array Input: https://laravel.com/docs/9.x/validation#validating-nested-array-input
                'users.*.email.email'       => 'Your email (field) must be a Valid email',   // Note: Submitted data is bulk/mulple JSON data/objects wrapped in a 'users' JSON Wrapping Object, and '*' (asterisk) denotes the array keys/indexes (e.g. 0, 1, 2, ...)    // Validating Nested Array Input: https://laravel.com/docs/9.x/validation#validating-nested-array-input
                'users.*.email.unique'      => 'Your email already exists in our database!', // Note: Submitted data is bulk/mulple JSON data/objects wrapped in a 'users' JSON Wrapping Object, and '*' (asterisk) denotes the array keys/indexes (e.g. 0, 1, 2, ...)    // Validating Nested Array Input: https://laravel.com/docs/9.x/validation#validating-nested-array-input

                'users.*.password.required' => 'Your password (field) is required'           // Note: Submitted data is bulk/mulple JSON data/objects wrapped in a 'users' JSON Wrapping Object, and '*' (asterisk) denotes the array keys/indexes (e.g. 0, 1, 2, ...)    // Validating Nested Array Input: https://laravel.com/docs/9.x/validation#validating-nested-array-input
            ];

            // $validator = \Illuminate\Support\Facades\Validator::make($userData, $rules);
            $validator = \Illuminate\Support\Facades\Validator::make($userData, $rules, $customMessages);

            // dd($validator->errors());   // is THE SAME AS:    dd($validator->messages());    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
            // dd($validator->messages()); // is THE SAME AS:    dd($validator->errors());      // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages

            if ($validator->fails()) {
                return response()->json($validator->errors(), 422);       // This is THE SAME AS the next line of code    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses     // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
                // return response()->json($validator->messages(), 422);  // This is THE SAME AS the last line of code    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses     // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
            }



            // Use a foreach loop because there are multiple JSON data/objects submitted in one go in the request    // Note: In Postman, JSON data are submitted using Curly Braces {} and a "users" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4
            // foreach ($userData as $key => $userDatum) {
            // foreach ($userData as $key => $value) {
            foreach ($userData['users'] as $key => $value) {
                // echo '<pre>', var_dump($key), '</pre>'; // "users"
                // echo '<pre>', var_dump($userDatum), '</pre>';
                // echo '<pre>', var_dump($userDatum['email']), '</pre>';
                // foreach ($userDatum as $key => $value) {
                //     echo '<pre>', var_dump($value['email']), '</pre>';
                // }

                // Add/Save the submitted new user data in `users` table ('name', 'email', 'password' fields must be submitted in Postman!)
                $user = new \App\Models\User;
                $user->name     = $value['name'];
                $user->email    = $value['email'];
                $user->password = bcrypt($value['password']); // Hash the password before storing it in the database table
                $user->save();
            }


            // Send back the newly submitted user data of the successful operation to the user again! (Note: This a well-known convention of APIs to send back the successful accepted data!)    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
            // return $user;          // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!
            return response()->json([ // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'message' => 'Users added successfully!'
                // 'users'   => $user
            ], 201); // 201 HTTP Status Code: Created    // With POST requests, 201 Created HTTP Status Code is sent with the HTTP Response    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

        } else { // if the user is using the wrong dedicated HTTP Request Method/Verb for their request (i.e. User has used an HTTP Request Method/Verb other than 'POST')
            $message = 'You are using an incorrect HTTP Method/Verb to access this route/endpoint in our API!';

            return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'status'  => false,
                'message' => $message
            ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
        }
    }

    // Update a Single user details (PUT)    // API Endpoint:    PUT http://127.0.0.1:8000/api/update-user-details Or PUT http://127.0.0.1:8000/api/update-user-details/23    // Note: In Postman, JSON data are submitted using Curly Braces {} and a "users" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'id', 'name', 'email' and 'password' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )     // https://www.youtube.com/watch?v=9ojV2kBRYLg&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=9
    public function updateUserDetails(Request $request, $id = null) { // Note: Query String Paramets (like 'id') can be submitted in THREE ways: using "Body" tab in Postman (as JSON data), as a URL Query String Parameters (e.g. www.example.com?id=3) and using Postman "Params" tab    // Note: When sending/submitting an HTTP Request to an API, whether GET, PUT, PATCH, DELETE requests, you can send your Query String Parameters with your request using THREE ways: first way: is the normal/regular way by sending your Query String Parameters in the request "Body", like for example, JSON data (e.g.    {"id": 10, "name": "John", "age": 10}    ), the second way: Although the used HTTP Method/Verb might NOT be GET, and you may be using a PUT/PATCH/DELETE request, you can send your Query String Parameters in the URL (e.g. www.example.com?id=10&name=John&age=24), and you can retrieve them in the backend using the $_GET superglobal (IMPORTANT: Despite the fact that the used HTTP Method/Verb is NOT "GET"), and of course no doubt, you can use this way with the GET HTTP Requests, the third way: use the "Params" tab in Postman to send your Query String Parameters Key/Value pairs in the dedicated fields in Postman (e.g. in Postman "Key" field write in "id", and in Postman "Value" field, write in "10" ).    // {id?}    Route Parameters: Optional Parameters: https://laravel.com/docs/9.x/routing#parameters-optional-parameters
        if ($request->isMethod('put')) { // Check if the incoming HTTP Request Method/Verb is 'PUT'
            $userData = $request->input();
            // $userData = $request->all();
            // dd($userData);
            // dd($userData['users']);
            /* echo '<pre>', var_dump($userData), '</pre>';
            echo '<pre>', var_dump($userData['users']), '</pre>';
            exit; */


            // Validation (Laravel Validation)    // https://www.youtube.com/watch?v=rWpHD4I1j8Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=8
            // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request! .    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
            // Manually Creating Validators: https://laravel.com/docs/9.x/validation#manually-creating-validators
            $rules = [
                // Fields/Column Names
                'name'     => 'required|regex:/^[\pL\s\-]+$/u', // regex:pattern: https://laravel.com/docs/9.x/validation#rule-regex
                // 'email'    => 'required|email|unique:users', // 'unique' validation rule in `users` datbase table    // unique:table,column: https://laravel.com/docs/9.x/validation#rule-unique
                'email'    => 'required|email', // 'unique' validation rule in `users` datbase table    // unique:table,column: https://laravel.com/docs/9.x/validation#rule-unique
                'password' => 'required'
            ];

            // Customizing Laravel's default error messages for every [Field with Validation Rule] e.g. the 'required' Validation Rule for the 'name' field    // Customizing The Error Messages: https://laravel.com/docs/9.x/validation#manual-customizing-the-error-messages
            $customMessages = [
                // The SAME last Fields (inside $rules array)
                'name.required'     => 'Your Name (field) is required',

                'email.required'    => 'Your email (field) is required',
                'email.email'       => 'Your email (field) must be a Valid email',
                // 'email.unique'      => 'Your email already exists in our database!',

                'password.required' => 'Your password (field) is required'
            ];

            // $validator = \Illuminate\Support\Facades\Validator::make($userData, $rules);
            $validator = \Illuminate\Support\Facades\Validator::make($userData, $rules, $customMessages);

            // dd($validator->errors());   // is THE SAME AS:    dd($validator->messages());    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
            // dd($validator->messages()); // is THE SAME AS:    dd($validator->errors());      // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages

            if ($validator->fails()) {
                return response()->json($validator->errors(), 422);       // This is THE SAME AS the next line of code    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses     // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
                // return response()->json($validator->messages(), 422);  // This is THE SAME AS the last line of code    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses     // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
            }



            // dd(isset($id) ? $id : $userData['id']); // if the id is sent as a URL Query String Parameter, take its value as is, or else, take its value from the JSON "Body"


            // Update submitted user details in `users` table
            \App\Models\User::where('id', isset($id) ? $id : $userData['id'])->update([ // if the id is sent as a URL Query String Parameter, take its value as is, or else, take its value from the JSON "Body"
                'name'     => $userData['name'],
                'email'    => $userData['email'],
                'password' => bcrypt($userData['password'])
            ]);


            // Send back the newly submitted user data of the successful operation to the user again! (Note: This a well-known convention of APIs to send back the successful accepted data!)    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
            // return $user;          // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!
            return response()->json([ // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'message' => 'User details updated successfully!'
                // 'users'   => $user
            ], 202); // 202 HTTP Status Code: Accepted    // With PUT/PATCH requests, 202 Accepted HTTP Status Code is sent with the HTTP Response    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

        } else { // if the user is using the wrong dedicated HTTP Request Method/Verb for their request (i.e. User has used an HTTP Request Method/Verb other than 'PUT')
            $message = 'You are using an incorrect HTTP Method/Verb to access this route/endpoint in our API!';

            return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'status'  => false,
                'message' => $message
            ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
        }
    }

    // Update the 'name' ONLY of a Single user (just a portion of a resource) (PATCH)    // API Endpoint:    PATCH http://127.0.0.1:8000/api/update-user-name Or PATCH http://127.0.0.1:8000/api/update-user-name/21    // Note: In Postman, JSON data are submitted using Curly Braces {} and a "users" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'id' and 'name' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )     // https://www.youtube.com/watch?v=4mibmxnJIsQ&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=10
    public function updateUserName(Request $request, $id = null) { // Note: Query String Paramets (like 'id') can be submitted in THREE ways: using "Body" tab in Postman (as JSON data), as a URL Query String Parameters (e.g. www.example.com?id=3) and using Postman "Params" tab    // Note: When sending/submitting an HTTP Request to an API, whether GET, PUT, PATCH, DELETE requests, you can send your Query String Parameters with your request using THREE ways: first way: is the normal/regular way by sending your Query String Parameters in the request "Body", like for example, JSON data (e.g.    {"id": 10, "name": "John", "age": 10}    ), the second way: Although the used HTTP Method/Verb might NOT be GET, and you may be using a PUT/PATCH/DELETE request, you can send your Query String Parameters in the URL (e.g. www.example.com?id=10&name=John&age=24), and you can retrieve them in the backend using the $_GET superglobal (IMPORTANT: Despite the fact that the used HTTP Method/Verb is NOT "GET"), and of course no doubt, you can use this way with the GET HTTP Requests, the third way: use the "Params" tab in Postman to send your Query String Parameters Key/Value pairs in the dedicated fields in Postman (e.g. in Postman "Key" field write in "id", and in Postman "Value" field, write in "10" ).    // {id?}    Route Parameters: Optional Parameters: https://laravel.com/docs/9.x/routing#parameters-optional-parameters
        if ($request->isMethod('patch')) { // Check if the incoming HTTP Request Method/Verb is 'PATCH'
            $userData = $request->input();
            // $userData = $request->all();
            // dd($userData);
            // dd($userData['users']);
            /* echo '<pre>', var_dump($userData), '</pre>';
            echo '<pre>', var_dump($userData['users']), '</pre>';
            exit; */



            // Validation (Laravel Validation)    // https://www.youtube.com/watch?v=rWpHD4I1j8Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=8
            // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request! .    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
            // Manually Creating Validators: https://laravel.com/docs/9.x/validation#manually-creating-validators
            $rules = [
                // Fields/Column Names
                'name'     => 'required|regex:/^[\pL\s\-]+$/u', // regex:pattern: https://laravel.com/docs/9.x/validation#rule-regex
            ];

            // Customizing Laravel's default error messages for every [Field with Validation Rule] e.g. the 'required' Validation Rule for the 'name' field    // Customizing The Error Messages: https://laravel.com/docs/9.x/validation#manual-customizing-the-error-messages
            $customMessages = [
                // The SAME last Fields (inside $rules array)
                'name.required'     => 'Your Name (field) is required'
            ];

            // $validator = \Illuminate\Support\Facades\Validator::make($userData, $rules);
            $validator = \Illuminate\Support\Facades\Validator::make($userData, $rules, $customMessages);

            // dd($validator->errors());   // is THE SAME AS:    dd($validator->messages());    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
            // dd($validator->messages()); // is THE SAME AS:    dd($validator->errors());      // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages

            if ($validator->fails()) {
                return response()->json($validator->errors(), 422);       // This is THE SAME AS the next line of code    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses     // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
                // return response()->json($validator->messages(), 422);  // This is THE SAME AS the last line of code    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses     // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
            }



            // dd(isset($id) ? $id : $userData['id']); // if the id is sent as a URL Query String Parameter, take its value as is, or else, take its value from the JSON "Body"


            // Update the `name` column of the submitted user 'id' and 'name' in `users` table
            \App\Models\User::where('id', isset($id) ? $id : $userData['id'])->update(['name' => $userData['name']]); // if the id is sent as a URL Query String Parameter, take its value as is, or else, take its value from the JSON "Body"


            // Send back the newly submitted user data of the successful operation to the user again! (Note: This a well-known convention of APIs to send back the successful accepted data!)    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
            // return $user;          // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!
            return response()->json([ // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'message' => 'User\'s name ONLY updated successfully!'
                // 'users'   => $user
            ], 202); // 202 HTTP Status Code: Accepted    // With PUT/PATCH requests, 202 Accepted HTTP Status Code is sent with the HTTP Response    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

        } else { // if the user is using the wrong dedicated HTTP Request Method/Verb for their request (i.e. User has used an HTTP Request Method/Verb other than 'PATCH')
            $message = 'You are using an incorrect HTTP Method/Verb to access this route/endpoint in our API!';

            return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'status'  => false,
                'message' => $message
            ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
        }
    }

    // Delete a Single user (DELETE)    // API Endpoint:    DELETE http://127.0.0.1:8000/api/delete-user Or DELETE http://127.0.0.1:8000/api/delete-user/32    // Note: In Postman, JSON data are submitted using Curly Braces {} and a "users" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'id' field must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )     // https://www.youtube.com/watch?v=Yg1715nXueU&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=11
    public function deleteUser(Request $request, $id = null) { // Note: Query String Paramets (like 'id') can be submitted in THREE ways: using "Body" tab in Postman (as JSON data), as a URL Query String Parameters (e.g. www.example.com?id=3) and using Postman "Params" tab    // Note: When sending/submitting an HTTP Request to an API, whether GET, PUT, PATCH, DELETE requests, you can send your Query String Parameters with your request using THREE ways: first way: is the normal/regular way by sending your Query String Parameters in the request "Body", like for example, JSON data (e.g.    {"id": 10, "name": "John", "age": 10}    ), the second way: Although the used HTTP Method/Verb might NOT be GET, and you may be using a PUT/PATCH/DELETE request, you can send your Query String Parameters in the URL (e.g. www.example.com?id=10&name=John&age=24), and you can retrieve them in the backend using the $_GET superglobal (IMPORTANT: Despite the fact that the used HTTP Method/Verb is NOT "GET"), and of course no doubt, you can use this way with the GET HTTP Requests, the third way: use the "Params" tab in Postman to send your Query String Parameters Key/Value pairs in the dedicated fields in Postman (e.g. in Postman "Key" field write in "id", and in Postman "Value" field, write in "10" ).    // {id?}    Route Parameters: Optional Parameters: https://laravel.com/docs/9.x/routing#parameters-optional-parameters
        if ($request->isMethod('delete')) { // Check if the incoming HTTP Request Method/Verb is 'DELETE'
            $userData = $request->input();
            // $userData = $request->all();
            // dd($userData);
            // dd($userData['users']);
            /* echo '<pre>', var_dump($userData), '</pre>';
            echo '<pre>', var_dump($userData['users']), '</pre>';
            exit; */



            // dd(isset($id) ? $id : $userData['id']); // if the id is sent as a URL Query String Parameter, take its value as is, or else, take its value from the JSON "Body"


            // Delete the submitted user 'id' from the `users` table
            \App\Models\User::where('id', isset($id) ? $id : $userData['id'])->delete(); // if the id is sent as a URL Query String Parameter, take its value as is, or else, take its value from the JSON "Body"


            // Send back the newly submitted user data of the successful operation to the user again! (Note: This a well-known convention of APIs to send back the successful accepted data!)    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
            // return $user;          // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!
            return response()->json([ // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'message' => 'User deleted successfully!'
                // 'users'   => $user
            ], 202/* 204 */); // 204 HTTP Status Code: No Content    // With DELETE requests, 204 No Content, 202 Accepted or 200 HTTP Status Code is sent with the HTTP Response    // Note: 204 No Content HTTP Status Code cancels out/hides any Messages you send back with your HTTP Response! (Your Message would disappear/vanish with your HTTP Response! Nothing at all will show up to the user!)    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

        } else { // if the user is using the wrong dedicated HTTP Request Method/Verb for their request (i.e. User has used an HTTP Request Method/Verb other than 'DELETE')
            $message = 'You are using an incorrect HTTP Method/Verb to access this route/endpoint in our API!';

            return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'status'  => false,
                'message' => $message
            ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
        }
    }

    // Delete Multiple users (DELETE)    // API Endpoint:    DELETE http://127.0.0.1:8000/api/delete-multiple-users Or DELETE http://127.0.0.1:8000/api/delete-multiple-users/11,13,20    // Note: In Postman, JSON data are submitted using Curly Braces {} and an "ids" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'ids' field must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )     // https://www.youtube.com/watch?v=YMbpobDj9r4&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=12
    public function deleteMultipleUsers(Request $request, $ids = null) { // Note: Query String Paramets (like 'id') can be submitted in THREE ways: using "Body" tab in Postman (as JSON data), as a URL Query String Parameters (e.g. www.example.com?id=3) and using Postman "Params" tab    // Note: When sending/submitting an HTTP Request to an API, whether GET, PUT, PATCH, DELETE requests, you can send your Query String Parameters with your request using THREE ways: first way: is the normal/regular way by sending your Query String Parameters in the request "Body", like for example, JSON data (e.g.    {"id": 10, "name": "John", "age": 10}    ), the second way: Although the used HTTP Method/Verb might NOT be GET, and you may be using a PUT/PATCH/DELETE request, you can send your Query String Parameters in the URL (e.g. www.example.com?id=10&name=John&age=24), and you can retrieve them in the backend using the $_GET superglobal (IMPORTANT: Despite the fact that the used HTTP Method/Verb is NOT "GET"), and of course no doubt, you can use this way with the GET HTTP Requests, the third way: use the "Params" tab in Postman to send your Query String Parameters Key/Value pairs in the dedicated fields in Postman (e.g. in Postman "Key" field write in "id", and in Postman "Value" field, write in "10" ).    // {id?}    Route Parameters: Optional Parameters: https://laravel.com/docs/9.x/routing#parameters-optional-parameters
        if ($request->isMethod('delete')) { // Check if the incoming HTTP Request Method/Verb is 'DELETE'
            $userData = $request->input();
            // $userData = $request->all();
            // dd($userData);
            // dd($userData['users']);
            /* echo '<pre>', var_dump($userData), '</pre>';
            echo '<pre>', var_dump($userData['users']), '</pre>';
            exit; */



            if (isset($ids)) { // if the ids are sent as a URL Query String Parameter, take its value as is, or else, take its values from the JSON (using the "Body" tab in Postman)
                $ids = array_map('trim', (explode(',', $ids))); // In case user adds spaces between ids in the URL like "http://127.0.0.1:8000/api/delete-multiple-users/20, 9 , 10" instead of "http://127.0.0.1:8000/api/delete-multiple-users/20,9,10", I used array_map() function here to apply the trim() function on EVERY array element of the array returned from the explode() function
                // dd($ids);

                // Delete the submitted users 'id's from the `users` table
                // dd(\App\Models\User::whereIn('id', $ids)->get()->toArray()); // Check the returned `users` records from the whereIn() method
                \App\Models\User::whereIn('id', $ids)->delete(); // Used whereIn() method instead of where() because we are getting (to delete) an ARRAY of ids

                // Send back the newly submitted user data of the successful operation to the user again! (Note: This a well-known convention of APIs to send back the successful accepted data!)    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
                // return $user;          // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!
                return response()->json([ // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                    'message' => 'Users deleted successfully!'
                    // 'users'   => $user
                ], 202/* 204 */); // 204 HTTP Status Code: No Content    // With DELETE requests, 204 No Content, 202 Accepted or 200 HTTP Status Code is sent with the HTTP Response    // Note: 204 No Content HTTP Status Code cancels out/hides any Messages you send back with your HTTP Response! (Your Message would disappear/vanish with your HTTP Response! Nothing at all will show up to the user!)    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

            } else { // if the ids are not sent as a URL Query String Parameter, but else, sent in the "Body" tab in Postman as JSON data

                // Delete the submitted users 'id's from the `users` table
                // dd(\App\Models\User::whereIn('id', $userData['ids'])->get()->toArray()); // Check the returned `users` records from the whereIn() method
                \App\Models\User::whereIn('id', $userData['ids'])->delete(); // Submitted/Sent JSON data are bulk/multiple JSON data/objects which are wrapped in an "ids" Wrapping Object, and Curly Braces {} and Square Brackets [] are used    // Used whereIn() method instead of where() because we are getting (to delete) an ARRAY of ids


                // Send back the newly submitted user data of the successful operation to the user again! (Note: This a well-known convention of APIs to send back the successful accepted data!)    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
                // return $user;          // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!
                return response()->json([ // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                    'message' => 'Users deleted successfully!'
                    // 'users'   => $user
                ], 202/* 204 */); // 204 HTTP Status Code: No Content    // With DELETE requests, 204 No Content, 202 Accepted or 200 HTTP Status Code is sent with the HTTP Response    // Note: 204 No Content HTTP Status Code cancels out/hides any Messages you send back with your HTTP Response! (Your Message would disappear/vanish with your HTTP Response! Nothing at all will show up to the user!)    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
            }

        } else { // if the user is using the wrong dedicated HTTP Request Method/Verb for their request (i.e. User has used an HTTP Request Method/Verb other than 'DELETE')
            $message = 'You are using an incorrect HTTP Method/Verb to access this route/endpoint in our API!';

            return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'status'  => false,
                'message' => $message
            ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
        }
    }

    // Register a new user (POST)    // API Endpoint:    POST http://127.0.0.1:8000/api/register-user    // Whenever a new user registers a new account using our Registration API Endpoint, we'll generate an Access Token for them to use and send with all their subsequent HTTP Requests (and will store it in the `api_token` column in `users` table). Note: Whenever the user logs in, we'll generate a new Access Token (that acts the same as a browser Session (i.e. Both Session and Access Token are sent from the client to the server with EVERY HTTP Request), except the fact that there's no browser Session here!) that will replace the old one in the `api_token` column in `users` table. This token will be valid only till the user logs out and then expires (by deleting it from the `api_token` column in the `users` database table when the user logs out)    // User can use the new Access Token that gets generated wheny they register a new account with all their subsequent HTTP Requests    // Note: In Postman, JSON data are submitted using Curly Braces {} and an "ids" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'name', 'email' and 'password' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )    // https://www.youtube.com/watch?v=9sVIw6iwywU&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=14
    public function registerUser(Request $request) {
        if ($request->isMethod('post')) { // Check if the incoming HTTP Request Method/Verb is 'POST'
            $userData = $request->input();
            // $userData = $request->all();
            // dd($userData);
            /* echo '<pre>', var_dump($userData), '</pre>';
            exit; */



            // Validation (Laravel Validation)    // https://www.youtube.com/watch?v=rWpHD4I1j8Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=8
            // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request! .    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
            // Manually Creating Validators: https://laravel.com/docs/9.x/validation#manually-creating-validators
            $rules = [
                // Fields/Column Names
                'name'     => 'required|regex:/^[\pL\s\-]+$/u', // regex:pattern: https://laravel.com/docs/9.x/validation#rule-regex
                'email'    => 'required|email|unique:users', // 'unique' validation rule in `users` datbase table    // unique:table,column: https://laravel.com/docs/9.x/validation#rule-unique
                'password' => 'required'
            ];

            // Customizing Laravel's default error messages for every [Field with Validation Rule] e.g. the 'required' Validation Rule for the 'name' field    // Customizing The Error Messages: https://laravel.com/docs/9.x/validation#manual-customizing-the-error-messages
            $customMessages = [
                // The SAME last Fields (inside $rules array)
                'name.required'     => 'Your Name (field) is required',

                'email.required'    => 'Your email (field) is required',
                'email.email'       => 'Your email (field) must be a Valid email',
                'email.unique'      => 'Your email already exists in our database!',

                'password.required' => 'Your password (field) is required'
            ];

            // $validator = \Illuminate\Support\Facades\Validator::make($userData, $rules);
            $validator = \Illuminate\Support\Facades\Validator::make($userData, $rules, $customMessages);

            // dd($validator->errors());   // is THE SAME AS:    dd($validator->messages());    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
            // dd($validator->messages()); // is THE SAME AS:    dd($validator->errors());      // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages

            if ($validator->fails()) {
                return response()->json($validator->errors(), 422);       // This is THE SAME AS the next line of code    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses     // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
                // return response()->json($validator->messages(), 422);  // This is THE SAME AS the last line of code    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses     // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
            }



            // Generate a new Access Token for the user, and save it in the `api_token` column in `users` table (and overwrite/override/replace the old Access Token in `api_token` column if there is any!)
            $apiToken = \Illuminate\Support\Str::random(60); // Str::random(): https://laravel.com/docs/9.x/helpers#method-str-random

            // Note: Access Tokens (e.g. JWT, regular tokens, â€¦) role in APIs act exactly the same as 'browser Session' (in Web Development world where the 'client' is the 'browser'), as both Access Tokens and Sessions are sent from the client to the server with EVERY HTTP Request. But, 'browser Sessions' are available only in 'browsers', which is not the case with APIs and Mobile/Android Applications for examlple. So, Access Tokens are used instead of 'browser Sessions' in clients that don't have Sessions. (i.e. Access Tokens are used in APIs and mobile phones as there is no browser Session available!)

            // Register the new user i.e. Save the submitted user data (name, email and password) along with the newly generated API Access Token in `users` table
            $user = new \App\Models\User;

            $user->name     = $userData['name'];
            $user->email    = $userData['email'];
            $user->password = bcrypt($userData['password']); // Hash the password before saving it in the database table

            $user->api_token = $apiToken;

            $user->save();


            // Send back the newly submitted user data of the successful operation to the user again! (Note: This a well-known convention of APIs to send back the successful accepted data!)    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
            // return $user;          // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!
            return response()->json([ // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'status'  => true,
                'message' => 'User registered successfully!',
                'token'   => $apiToken,
                'user'    => $user
            ], 201);  // 201 HTTP Status Code: Created    // With POST requests, 201 Created HTTP Status Code is sent with the HTTP Response    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

        } else { // if the user is using the wrong dedicated HTTP Request Method/Verb for their request (i.e. User has used an HTTP Request Method/Verb other than 'POST')
            $message = 'You are using an incorrect HTTP Method/Verb to access this route/endpoint in our API!';

            return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'status'  => false,
                'message' => $message
            ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
        }
    }

    // Log in a user and Generate a new Access Token for them (POST)    // API Endpoint:    POST http://127.0.0.1:8000/api/login-user    // Whenever a new user registers a new account using our Registration API Endpoint, we'll generate an Access Token for them to use and send with all their subsequent HTTP Requests (and will store it in the `api_token` column in `users` table). Note: Whenever the user logs in, we'll generate a new Access Token (that acts the same as a browser Session (i.e. Both Session and Access Token are sent from the client to the server with EVERY HTTP Request), except the fact that there's no browser Session here!) that will replace the old one in the `api_token` column in `users` table. This token will be valid only till the user logs out and then expires (by deleting it from the `api_token` column in the `users` database table when the user logs out)    // User must send an "Authorization" HTTP Header with all their subsequent HTTP Requests with the value of the "Bearer" Accesss Token that they received in the HTTP Response when they first logged in or when they first registered their brand-new account. The "Bearer" Access Token should be sent in the following form:    "Bearer xxxxxxxxxxxxxxxxxx"    where xxxxxxxxxxxxxxxxxx is the "Bearer" Access Token value.    // Note: In Postman, JSON data are submitted using Curly Braces {} and an "ids" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'email' and 'password' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )    // https://www.youtube.com/watch?v=8DybucZ310c&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=15
    public function loginUser(Request $request) {
        if ($request->isMethod('post')) { // Check if the incoming HTTP Request Method/Verb is 'POST'
            $userData = $request->input();
            // $userData = $request->all();
            // dd($userData);
            /* echo '<pre>', var_dump($userData), '</pre>';
            exit; */



            // Validation (Laravel Validation)    // https://www.youtube.com/watch?v=rWpHD4I1j8Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=8
            // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request! .    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
            // Manually Creating Validators: https://laravel.com/docs/9.x/validation#manually-creating-validators
            $rules = [
                // Fields/Column Names
                'email'    => 'required|email|exists:users', // 'exists' validation rule in `users` datbase table    // exists:table,column: https://laravel.com/docs/9.x/validation#rule-exists
                'password' => 'required'
            ];

            // Customizing Laravel's default error messages for every [Field with Validation Rule] e.g. the 'required' Validation Rule for the 'name' field    // Customizing The Error Messages: https://laravel.com/docs/9.x/validation#manual-customizing-the-error-messages
            $customMessages = [
                // The SAME last Fields (inside $rules array)
                'email.required'    => 'Your email (field) is required',
                'email.email'       => 'Your email (field) must be a Valid email',
                'email.exists'      => 'Your email does not exist in our database!',

                'password.required' => 'Your password (field) is required'
            ];

            // $validator = \Illuminate\Support\Facades\Validator::make($userData, $rules);
            $validator = \Illuminate\Support\Facades\Validator::make($userData, $rules, $customMessages);

            // dd($validator->errors());   // is THE SAME AS:    dd($validator->messages());    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
            // dd($validator->messages()); // is THE SAME AS:    dd($validator->errors());      // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages

            if ($validator->fails()) {
                return response()->json($validator->errors(), 422);       // This is THE SAME AS the next line of code    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses     // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
                // return response()->json($validator->messages(), 422);  // This is THE SAME AS the last line of code    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses     // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    // Working With Error Messages: https://laravel.com/docs/9.x/validation#working-with-error-messages
            }



            // Fetch/Get the submitted user record (their `users` table row) from `users` table based on the submitted `email` in order to verify the submitted `password`
            $userDetails = \App\Models\User::where('email', $userData['email'])->first();

            // Verify the submitted Password (compare the submitted password (N.B. It gets hashed before comparing by password_verify() function) with the "hashed" `password` in `users` table). If both the submitted password and the user's password in the database table match, we generate a new Access Token for the user to use and send it with all their subsequent HTTP Requests, and update `api_token` column in `users` table with that new Access Token (we replace the old one with the new one)
            if (password_verify($userData['password'], $userDetails->password)) {
                // Generate a new Access Token for the user to use and send it with all their subsequent HTTP Requests
                $apiToken = \Illuminate\Support\Str::random(60); // Str::random(): https://laravel.com/docs/9.x/helpers#method-str-random

                // Note: Access Tokens (e.g. JWT, regular tokens, â€¦) role in APIs act exactly the same as 'browser Session' (in Web Development world where the 'client' is the 'browser'), as both Access Tokens and Sessions are sent from the client to the server with EVERY HTTP Request. But, 'browser Sessions' are available only in 'browsers', which is not the case with APIs and Mobile/Android Applications for examlple. So, Access Tokens are used instead of 'browser Sessions' in clients that don't have Sessions. (i.e. Access Tokens are used in APIs and mobile phones as there is no browser Session available!)

                // Update `api_token` column in `users` table with the new Access Token (We replace the old one with the new one)
                \App\Models\User::where('email', $userData['email'])->update(['api_token' => $apiToken]);


                // Send back the newly submitted user data of the successful operation to the user again! (Note: This a well-known convention of APIs to send back the successful accepted data!)    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
                // return $user;          // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!
                return response()->json([ // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                    'status'  => true,
                    'message' => 'User logged in successfully!',
                    'token'   => $apiToken
                ], 201);  // 201 HTTP Status Code: Created    // With POST requests, 201 Created HTTP Status Code is sent with the HTTP Response    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

            } else { // if the submitted Password (to log in) is incorrect

                return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                    'status'  => false,
                    'message' => 'Password is incorrect!'
                ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    

            }

        } else { // if the user is using the wrong dedicated HTTP Request Method/Verb for their request (i.e. User has used an HTTP Request Method/Verb other than 'POST')

            $message = 'You are using an incorrect HTTP Method/Verb to access this route/endpoint in our API!';

            return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'status'  => false,
                'message' => $message
            ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

        }
    }

    // Log out a user and Delete their current Access Token (POST)    // API Endpoint:    POST http://127.0.0.1:8000/api/logout-user    // Whenever a new user registers a new account using our Registration API Endpoint, we'll generate an Access Token for them to use and send with all their subsequent HTTP Requests (and will store it in the `api_token` column in `users` table). Note: Whenever the user logs in, we'll generate a new Access Token (that acts the same as a browser Session (i.e. Both Session and Access Token are sent from the client to the server with EVERY HTTP Request), except the fact that there's no browser Session here!) that will replace the old one in the `api_token` column in `users` table. This token will be valid only till the user logs out and then expires (by deleting it from the `api_token` column in the `users` database table when the user logs out)    // User must send an "Authorization" HTTP Header with all their subsequent HTTP Requests with the value of the "Bearer" Accesss Token that they received in the HTTP Response when they first logged in or when they first registered their brand-new account. The "Bearer" Access Token should be sent in the following form:    "Bearer xxxxxxxxxxxxxxxxxx"    where xxxxxxxxxxxxxxxxxx is the "Bearer" Access Token value.    // Note: In Postman, JSON data are submitted using Curly Braces {} and an "ids" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // No fields must be submitted by the user (from Postman) here! That's because the user will be identified through their Access Token sent (as 'Authorization' HTTP Header) with their HTTP Request to the server. Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )    // https://www.youtube.com/watch?v=Bka0Tdm1ByE&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=16
    public function logoutUser(Request $request) {
        if ($request->isMethod('post')) { // Check if the incoming HTTP Request Method/Verb is 'POST'
            $api_token = $request->header('Authorization'); // Get the 'Authorization' HTTP Header sent from the user's client to the server with their HTTP Request    // Request Headers: https://laravel.com/docs/9.x/requests#request-headers
            // dd($api_token);

            if (empty($api_token)) { // if the user didn't send the 'Authorization' HTTP Header with their HTTP Request at all
                return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                    'status'  => false,
                    'message' => '\'Authorization\' HTTP Header (Bearer Access Token) is missing!'
                ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.    

            } else { // if the user sent the 'Authorization' HTTP Header (i.e. the Bearer Access Token) with their HTTP Request

                // Check if the submitted 'Authorization' HTTP Header value (i.e. the Bearer Access Token) exists in `users` database table
                // Remove the 'Bearer ' portion of the string of the Bearer Access token value of the 'Authorization' HTTP Header (as the 'Authorization' HTTP Header is sent in the form of:    'Bearer xxxxxxxxxxxxxxxxxxxxxx' e.g.    'Bearer K7qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyEp'    )
                // $api_token = substr($api_token, 7);                  // using substr() function
                $api_token = str_replace('Bearer ', '', $api_token);    // using str_replace() function
                // dd($api_token);

                $api_token_count = \App\Models\User::where('api_token', $api_token)->count();
                // dd($api_token_Count);
                if ($api_token_count > 0) { // if the submitted 'Authorization' HTTP Header value (i.e. the Bearer Access Token) exists in the `api_token` column in `users` database table, delete (not delete exactly!, just UPDATE the column value to 'null') it to expire the Access Token, so that the user can no longer use it to access their account
                    \App\Models\User::where('api_token', $api_token)->update(['api_token' => null]);

                    // Send back the newly submitted user data of the successful operation to the user again! (Note: This a well-known convention of APIs to send back the successful accepted data!)    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
                    // return $user;          // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!
                    return response()->json([ // Note: $user is AUTOMATICALLY converted from Laravel/PHP object to JSON! But we'll manually convert it to JSON using    return response()->json()    to show the "users" JSON property key/name in the response! Try the TWO cases and check the difference in Postman in "Pretty" tab!    // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                        'status'  => true,
                        'message' => 'User logged out successfully!',
                        // 'user'    => $user
                    ], 200); // 200 HTTP Status Code: OK    // With GET requests, 200 OK HTTP Status Code is sent with the HTTP Response    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

                } else { // if the submitted 'Authorization' HTTP Header value (i.e. the Bearer Access Token) doesn't exist in the `api_token` column in `users` database table
                    return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                        'status'  => false,
                        'message' => 'Your submitted \'Authorization\' HTTP Header value (i.e. the Bearer Access Token) does not exist in our database!'
                    ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.        
                }

            }

        } else { // if the user is using the wrong dedicated HTTP Request Method/Verb for their request (i.e. User has used an HTTP Request Method/Verb other than 'POST')

            $message = 'You are using an incorrect HTTP Method/Verb to access this route/endpoint in our API!';

            return response()->json([ // JSON Responses: https://laravel.com/docs/9.x/responses#json-responses
                'status'  => false,
                'message' => $message
            ], 422); // 422 HTTP Status Code: Unprocessable Content    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.

        }
    }

}
