<?php

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;

/*
|--------------------------------------------------------------------------
| API Routes
|--------------------------------------------------------------------------
|
| Here is where you can register API routes for your application. These
| routes are loaded by the RouteServiceProvider within a group which
| is assigned the "api" middleware group. Enjoy building your API!
|
*/

Route::middleware('auth:sanctum')->get('/user', function (Request $request) { // API Endpoint: GET http://127.0.0.1:8000/api/user
    return $request->user();
});


// https://www.youtube.com/playlist?list=PLLUtELdNs2ZaPSOuYoosmSj5TUuXjl_uu
// For Shiprocket API Integration (N.B. you should create a new 'API' folder and a new 'APIController.php' file for all your integrated APIs. N.B. while working with APIs, you'll use Laravel "api.php" file instead of "web.php" file, and all of your API endpoints/routes/links in "api.php" file will automatically be prefixed with/have the "api" word like this example:     www.example.com/api/orders/create     ), check     https://www.youtube.com/watch?v=mcSoGDSrdsU&list=PLLUtELdNs2ZaPSOuYoosmSj5TUuXjl_uu&index=2     (For the complete API integration Playlist, check https://www.youtube.com/playlist?list=PLLUtELdNs2ZaPSOuYoosmSj5TUuXjl_uu)
// Note: When working with APIs (like working in APIController.php), everything returned must be in JSON format.
// Note: To access (open) the API routes (endpoints) (in api.php), you must prefix all your routes with     '/api/'     e.g.     http://127.0.0.1:8000/api/posts     , but you don't have to write (prefix) your routes themselves in the api.php file with the '/api/' prefix (i.e. you don't need to write it with '/api/' and just write it like this: Route::get('/posts', function() {   . Check 26:22 in https://www.youtube.com/watch?v=MYyJ4PuL4pY
// Shiprocket API Documentation: https://apidocs.shiprocket.in/


// Route::namespace('API')->group(function() { // Route Groups: https://laravel.com/docs/9.x/routing#route-groups
Route::namespace('App\Http\Controllers\API')->group(function() { // Route Groups: https://laravel.com/docs/9.x/routing#route-groups
    // Push our 'ecom9' website orders (from our `orders` database table) to Shiprocket    // https://www.youtube.com/watch?v=mcSoGDSrdsU&list=PLLUtELdNs2ZaPSOuYoosmSj5TUuXjl_uu&index=2
    Route::get('push-order/{id}', 'APIController@pushOrder'); // This route/URL/link is: GET http://127.0.0.1:8000/api/push-order/3    // Route Parameters: Required Parameters: https://laravel.com/docs/9.x/routing#required-parameters

    // 











    // Our ecom9 Website API: https://www.youtube.com/playlist?list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE
    // Note: It's a well-known/common convention of APIs (and how they work) to send back successfully accepted/saved data (in BOTH cases of: Creating/Adding New data using a POST request, or Updating existing data using a PUT/PATCH request) (data accepted from the user and saved in the database for example (Whether Create/Add new data by a POST request or Update (PUT/PATCH) already existing data)) which are posted/submitted by the user to the user again as an HTTP Response, along with a Success/Failure Message. (to show the user their accepted data again!). For example, if the user uses a "Create an Album" POST API Endpoint, and submits fields like: 'album_name', 'album_type', 'album_size', ...etc, so if their entered data are accepted by the API and have been saved in the database, the API sends back those entered data to the user as a JSON HTTP Response, along with a Success/Failure Message.
    // Note: When you build an API, you must send the correct RELEVANT HTTP Status Code with every HTTP Response! - It's a convention in APIs (take care when building your API!) that in case of failing Validation or there are any kind of errors with your HTTP Request sent to the API that they send back with the HTTP Response the relevant correct HTTP Status Code (which will be anything other than the 200 OK!) like 404, 422, ...etc. This is because ALL THE TIME/FOREVER the API by default will send the 200 OK HTTP Status Code with the HTTP Responses (regardless of whether there are errors with the request or not), which is not an accurate or correct thing! . Also, make sure to send back the RELEVANT HTTP Status Code (with your HTTP Response) to every Successful HTTP Request! e.g. send back the 200 OK HTTP Status Code with your HTTP Response for good/successful HTTP Requests, or the 201 Created HTTP Status Code if the successful HTTP Request led to Creation of records in the database, ...etc. . Also, Make sure to send back the 200 OK HTTP Status Code with your HTTP Response for every good/successful HTTP Request!
    // Note: To sum up, when you build your API, with every HTTP Response, you must send back the submitted and accepted (saved in the database) data (mostly in JSON format) to the user, along with the RELEVANT HTTP Status Code, along with a Success/Failure Message.
    // Note: When sending/submitting an HTTP Request to an API, whether GET, PUT, PATCH, DELETE requests, you can send your Query String Parameters with your request using THREE ways: first way: is the normal/regular way by sending your Query String Parameters in the request "Body", like for example, JSON data (e.g. "id": 10), the second way: Although the used HTTP Method/Verb might NOT be GET, and you may be using a PUT/PATCH/DELETE request, you can send your Query String Parameters in the URL (e.g. www.example.com?id=10&name=John&age=24), and you can retrieve them in the backend using the $_GET superglobal (IMPORTANT: Despite the fact that the used HTTP Method/Verb is NOT "GET"), and of course no doubt, you can use this way with the GET HTTP Requests, the third way: use the "Params" tab in Postman to send your Query String Parameters Key/Value pairs in the dedicated fields in Postman (e.g. in Postman "Key" field write in "id", and in Postman "Value" field, write in "10" ).
    // Note: The relation between the HTTP Status Codes of the HTTP Responses & the HTTP Methods/Verbs used in the HTTP Requests when sending back an HTTP Response for an HTTP Request: If you're building your API, for GET requests, send back 200 OK HTTP Status Code with your HTTP Response, and for POST requests, send back 201 Created HTTP Status Code with your HTTP Response, and for PUT/PATCH requests, send back 202 Accepted HTTP Status Code with your HTTP Response, and for DELETE requests, send back 204 No Content, 202 Accepted or 200 OK HTTP Status Code with your HTTP Response.
    // Note: Access Tokens (e.g. JWT, regular tokens, â€¦) role in APIs act exactly the same as 'browser Session' (in Web Development world where the 'client' is the 'browser'), as both Access Tokens and Sessions are sent from the client to the server with EVERY HTTP Request. But, 'browser Sessions' are available only in 'browsers', which is not the case with APIs and Mobile/Android Applications for examlple. So, Access Tokens are used instead of 'browser Sessions' in clients that don't have Sessions. (i.e. Access Tokens are used in APIs and mobile phones as there is no browser Session available!)
    // Note: The Registration (for the first time), Validation, Authentication/Login, browser Session and Logout Processes Workflow (Story) in Web Development: In Web Development world, the client is the 'browser', and where there is a browser Session. So, Registration for the first time Process: Everything starts with a user registers a new account with their email and password, we validate those submitted data (we make sure the email is a valid email, and it doesn't already exist in our database table, and it's 'required' i.e. not optional), then we save those validated data in our database table (for later authentication/login), and if all this were OK, we generate a new Session on the server for this specific user, which is sent to the client (the client is the browser in this case) as a browser Cookie (which holds a Session ID). This Cookie/Session ID is sent with every subsequent HTTP Request that the user makes from the client (the broswer in this case), this Session ID tells the server that this is the user that is logged in (the server identifies the user through that Session ID). Protected Routes: Every page in the website which requires the user to be authenticated/logged-in (such as Profile page, Orders page, ...) must check if the user sending the HTTP Request exists on the server's Session, to allow the user to continue sending HTTP Requests to access those Protected Routes on the website. We expire this session when the user logs out, so if the user makes a subsequent request after logging out, the server doesn't respond with an HTTP Response because the Session Cookie that the browser sends to the server has been deleted from the server when the user logged out. Authentication/Login Process: When the user logs in to their account, we do validation on their submitted data (we check if the submitted email already exists in our database table or not, then we verify that the submitted password (the hashed one) matches the hashed password in our database table), if all this were OK, we generate a new Session on the server, and the client (which is the browser in this case) stores a new Session Cookie (received from the server) that has a Session ID. This Session Cookie is sent by the client (the browser in this case) with EVERY HTTP Request the client (i.e. the broswer in this case) makes in order for the server to identify the logged-in user by comparing the Session ID of the Cookie sent from the client (i.e. browser) with the Session ID stored on the server. When the user logs out, the Session gets expired on the server (deleted), and the client's (i.e the browser in this case) browser's Session Cookie no longer works, so the user must login again in order for the server to generate a new Session for them.

    // Note: The Registration, Validation, Authentication/Login, Access Tokens (act exactly as 'browser Sessions' because of the fact that there is no browser here in APIs!) and Logout Processes Workflow (Story) in APIs: In APIs field, we try to simulate/imitate everything that happens in the Web Development world where the 'client' is the 'browser' and where there is a 'browser Session', but with APIs (as with the case of Mobile/Android applications, for example), there is no browser nor there is no Session (that's why we use Access Tokens instead of 'browser Sessions'). So, Registration for the first time Process: Everything starts with a user registers a new account with their email and password, we validate those submitted data (we make sure the email is a valid email, and it doesn't already exist in our database table, and it's 'required' i.e. not optional), and if submitted data passes our validation, we generate a new Access Token for this specific user, then we save those validated data and the newly generated Access Token in our database table (for later authentication/login), then we send the Access Token to the client as a JSON HTTP Response to their HTTP Request. This Access Token must be sent by the user an 'Authorization' HTTP Header with EVERY subsequent HTTP Request (JUST LIKE THE SESSION IN CASE OF BROWSERS (in Web Development)) that the user makes from their client, this Access Token gets compared on the server with that specific user's Access Token which is saved in our database table to make sure this is the user! (to keep them logged-in JUST LIKE THE CASE OF SESSION IN BROWSERS). Protected Routes: All your API endpoints (all your routes methods in APIController) in your API must check if the 'Authorization' HTTP Header (i.e. Access Token) is provided/sent by the client to the server (just like Protected Routes in Web Development (Laravel) where every page in a website that requires the user to be authenticated/logged-in (such as Profile page, Orders page, ...) checks if there is a user stored on the server's Session or not, to allow the user to continue sending their HTTP Requests to access those Protected Routes) (except for the Registration API endpoint and the Login API endpoint, those two API endpoins don't check the Access Token because they are already generating one) and check if that Access Token exists or not in your database table (this is done to not allow the user to further use/access your API endpoints unless they have an Access Token and they have the correct one!). We expire this Access Token when the user logs out by deleting it from the database table when the user logs out, so if the user makes a subsequent request after logging out, the server doesn't respond with an HTTP Response (we just send a "You're logged out!" JSON HTTP Response message) because their Access Token that user's client sends to the server has been deleted from the database table when the user logged out. Authentication/Login: When the user logs in to their account, we do validation on their submitted data (we check if the submitted email already exists in our database table or not, then we verify that the submitted password (the hashed one) matches the hashed password in our database table), if all this were OK, we generate a new Access Token for the user, then we replace/update the user's old Access Token with the new one in the database table, and then we send the user the new Access Token in a JSON HTTP Response. This Access Token must be sent by the client with EVERY HTTP Request the client makes in order for the server to identify the logged-in user. When the user logs out, we expire the Access Token by deleting it from the database table, and the client's current Access Token no longer works, so the user must login again in order for the server to generate a new Access Token for them and update the database table with it.
    // Note: As a convention of how APIs work, the 'Authorization' HTTP Header is sent with the HTTP Request as a "Bearer Token" (in "Headers" tab in Postman) in the following form:     "Bearer xxxxxxxxxxxxxxxxxxxxxxxxxxxx"     where 'xxxxxxxxx' is the Access Token. Ex:     "Bearer L8qq9PZyRg6ieKGEKhZolGC0vJWLw8iEJ88DRdyOg"


    // Get ALL users    Or    Get a SINGLE user (GET)    (depending on if the {id?} Optional Paramter specified or not in the API Endpoint route)    // API Endpoint:    GET http://127.0.0.1:8000/api/users Or GET http://127.0.0.1:8000/api/users/37    // User must send an "Authorization" HTTP Header with all their HTTP Requests with this value (Bearer Token (JWT)): "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFtaXQgR3VwdGEiLCJpYXQiOjE1MTYyMzkwMjJ9.cNrgi6Sso9wvs4GlJmFnA4IqJY4o2QEcKXgshJTjfNg"    // https://www.youtube.com/watch?v=ItB3CjQlidk&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=2
    Route::get('users/{id?}', 'APIController@getUsers'); // {id?}    Route Parameters: Optional Parameters: https://laravel.com/docs/9.x/routing#parameters-optional-parameters

    // Create a Single user (POST)    // API Endpoint:    POST http://127.0.0.1:8000/api/add-user    // 'name', 'email' and 'password' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )     // https://www.youtube.com/watch?v=_2OnU1mrOCc&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=3
    Route::post('add-user', 'APIController@addUser');

    // Create Multiple users (also works for Create a Single user) (POST)    // API Endpoint:    POST http://127.0.0.1:8000/api/add-multiple-users    // Note: In Postman, JSON data are submitted using Curly Braces {} and a "users" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'name', 'email' and 'password' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )     // https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4
    Route::post('add-multiple-users', 'APIController@addMultipleUsers');

    // Update a Single user details (PUT)    // API Endpoint:    PUT http://127.0.0.1:8000/api/update-user-details Or PUT http://127.0.0.1:8000/api/update-user-details/23    // Note: In Postman, JSON data are submitted using Curly Braces {} and a "users" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'id', 'name', 'email' and 'password' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )     // https://www.youtube.com/watch?v=9ojV2kBRYLg&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=9
    Route::put('update-user-details/{id?}', 'APIController@updateUserDetails'); // {id?}    Route Parameters: Optional Parameters: https://laravel.com/docs/9.x/routing#parameters-optional-parameters

    // Update the 'name' ONLY of a Single user (just a portion of a resource) (PATCH)    // API Endpoint:    PATCH http://127.0.0.1:8000/api/update-user-name Or PATCH http://127.0.0.1:8000/api/update-user-name/21    // Note: In Postman, JSON data are submitted using Curly Braces {} and a "users" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'id', 'name' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )     // https://www.youtube.com/watch?v=4mibmxnJIsQ&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=10
    Route::patch('update-user-name/{id?}', 'APIController@updateUserName'); // {id?}    Route Parameters: Optional Parameters: https://laravel.com/docs/9.x/routing#parameters-optional-parameters

    // Delete a Single user (DELETE)    // API Endpoint:    DELETE http://127.0.0.1:8000/api/delete-user Or DELETE http://127.0.0.1:8000/api/delete-user/32    // Note: In Postman, JSON data are submitted using Curly Braces {} and a "users" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'id' field must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )     // https://www.youtube.com/watch?v=Yg1715nXueU&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=11
    Route::delete('delete-user/{id?}', 'APIController@deleteUser'); // {id?}    Route Parameters: Optional Parameters: https://laravel.com/docs/9.x/routing#parameters-optional-parameters

    // Delete Multiple users (DELETE)    // API Endpoint:    DELETE http://127.0.0.1:8000/api/delete-multiple-users Or DELETE http://127.0.0.1:8000/api/delete-multiple-users/11,13,20    // Note: In Postman, JSON data are submitted using Curly Braces {} and an "ids" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'ids' field must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )     // https://www.youtube.com/watch?v=YMbpobDj9r4&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=12
    Route::delete('delete-multiple-users/{ids?}', 'APIController@deleteMultipleUsers'); // {id?}    Route Parameters: Optional Parameters: https://laravel.com/docs/9.x/routing#parameters-optional-parameters

    // Register a new user and Generate a new Access Token for them (POST)    // API Endpoint:    POST http://127.0.0.1:8000/api/register-user    // Whenever a new user registers a new account using our Registration API Endpoint, we'll generate an Access Token for them to use and send with all their subsequent HTTP Requests (and will store it in the `api_token` column in `users` table). Note: Whenever the user logs in, we'll generate a new Access Token (that acts the same as a browser Session (i.e. Both Session and Access Token are sent from the client to the server with EVERY HTTP Request), except the fact that there's no browser Session here!) that will replace the old one in the `api_token` column in `users` table. This token will be valid only till the user logs out and then expires (by deleting it from the `api_token` column in the `users` database table when the user logs out)    // User can use the new Access Token that gets generated wheny they register a new account with all their subsequent HTTP Requests    // Note: In Postman, JSON data are submitted using Curly Braces {} and an "ids" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'name', 'email' and 'password' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )    // https://www.youtube.com/watch?v=9sVIw6iwywU&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=14
    Route::post('register-user', 'APIController@registerUser');

    // Log in a user and Generate a new Access Token for them (POST)    // API Endpoint:    POST http://127.0.0.1:8000/api/login-user    // Whenever a new user registers a new account using our Registration API Endpoint, we'll generate an Access Token for them to use and send with all their subsequent HTTP Requests (and will store it in the `api_token` column in `users` table). Note: Whenever the user logs in, we'll generate a new Access Token (that acts the same as a browser Session (i.e. Both Session and Access Token are sent from the client to the server with EVERY HTTP Request), except the fact that there's no browser Session here!) that will replace the old one in the `api_token` column in `users` table. This token will be valid only till the user logs out and then expires (by deleting it from the `api_token` column in the `users` database table when the user logs out)    // User must send an "Authorization" HTTP Header with all their subsequent HTTP Requests with the value of the "Bearer" Accesss Token that they received in the HTTP Response when they first logged in or when they first registered their brand-new account. The "Bearer" Access Token should be sent in the following form:    "Bearer xxxxxxxxxxxxxxxxxx"    where xxxxxxxxxxxxxxxxxx is the "Bearer" Access Token value.    // Note: In Postman, JSON data are submitted using Curly Braces {} and an "ids" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'email' and 'password' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )    // https://www.youtube.com/watch?v=8DybucZ310c&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=15
    Route::post('login-user', 'APIController@loginUser');

    // Log out a user and Delete their current Access Token (POST)    // API Endpoint:    POST http://127.0.0.1:8000/api/logout-user    // Whenever a new user registers a new account using our Registration API Endpoint, we'll generate an Access Token for them to use and send with all their subsequent HTTP Requests (and will store it in the `api_token` column in `users` table). Note: Whenever the user logs in, we'll generate a new Access Token (that acts the same as a browser Session (i.e. Both Session and Access Token are sent from the client to the server with EVERY HTTP Request), except the fact that there's no browser Session here!) that will replace the old one in the `api_token` column in `users` table. This token will be valid only till the user logs out and then expires (by deleting it from the `api_token` column in the `users` database table when the user logs out)    // User must send an "Authorization" HTTP Header with all their subsequent HTTP Requests with the value of the "Bearer" Accesss Token that they received in the HTTP Response when they first logged in or when they first registered their brand-new account. The "Bearer" Access Token should be sent in the following form:    "Bearer xxxxxxxxxxxxxxxxxx"    where xxxxxxxxxxxxxxxxxx is the "Bearer" Access Token value.    // Note: In Postman, JSON data are submitted using Curly Braces {} and an "ids" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // No fields must be submitted by the user (from Postman) here! That's because the user will be identified through their Access Token sent (as 'Authorization' HTTP Header) with their HTTP Request to the server. Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )    // https://www.youtube.com/watch?v=Bka0Tdm1ByE&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=16
    Route::post('logout-user', 'APIController@logoutUser');



    // API Endpoints/Routes using "Laravel Passport" package Authentication:

    // Register a new user and Generate a new Access Token for them Using "Passport" (POST)    // API Endpoint:    POST http://127.0.0.1:8000/api/register-user-with-passport    // Whenever a new user registers a new account using our Registration API Endpoint, we'll generate an Access Token for them to use and send with all their subsequent HTTP Requests (and will store it in the `api_token` column in `users` table). Note: Whenever the user logs in, we'll generate a new Access Token (that acts the same as a browser Session (i.e. Both Session and Access Token are sent from the client to the server with EVERY HTTP Request), except the fact that there's no browser Session here!) that will replace the old one in the `api_token` column in `users` table. This token will be valid only till the user logs out and then expires (by deleting it from the `api_token` column in the `users` database table when the user logs out)    // User can use the new Access Token that gets generated wheny they register a new account with all their subsequent HTTP Requests    // Note: In Postman, JSON data are submitted using Curly Braces {} and an "ids" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'name', 'email' and 'password' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )    // https://www.youtube.com/watch?v=9sVIw6iwywU&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=14
    Route::post('register-user-with-passport', 'APIController@registerUserWithPassport');

    // Log in a user and Generate a new Access Token for them Using "Passport" (POST)    // API Endpoint:    POST http://127.0.0.1:8000/api/login-user-with-passport    // Whenever a new user registers a new account using our Registration API Endpoint, we'll generate an Access Token for them to use and send with all their subsequent HTTP Requests (and will store it in the `api_token` column in `users` table). Note: Whenever the user logs in, we'll generate a new Access Token (that acts the same as a browser Session (i.e. Both Session and Access Token are sent from the client to the server with EVERY HTTP Request), except the fact that there's no browser Session here!) that will replace the old one in the `api_token` column in `users` table. This token will be valid only till the user logs out and then expires (by deleting it from the `api_token` column in the `users` database table when the user logs out)    // User must send an "Authorization" HTTP Header with all their subsequent HTTP Requests with the value of the "Bearer" Accesss Token that they received in the HTTP Response when they first logged in or when they first registered their brand-new account. The "Bearer" Access Token should be sent in the following form:    "Bearer xxxxxxxxxxxxxxxxxx"    where xxxxxxxxxxxxxxxxxx is the "Bearer" Access Token value.    // Note: In Postman, JSON data are submitted using Curly Braces {} and an "ids" Wrapping Object and Square Brackets []). Check 5:50 in https://www.youtube.com/watch?v=BduIZFOnc3Y&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=4    // 'email' and 'password' fields must be submitted by the user (from Postman). Note: Data can be posted/sent/submitted in Postman using a GET/POST/PUT/PATCH/DELETE request using TWO ways: First: "form-data" (resembles the HTML Form <input> fields (key/value pairs) and their "name" and "value" <input> HTML tag attributes, and you can retrieve those data in the backend using the Superglobals $_POST and $_FILES), Second: "raw" (through which you can decide the data type of the whole HTTP Request Body (e.g. JSON, HTML, ...etc), and you can retrieve those data in the backend using, for example if data were JSON, json_decode() function and then access the JSON key/value pairs as follows:    $jsonImageAttributes->filename    )    // https://www.youtube.com/watch?v=8DybucZ310c&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=15
    Route::post('login-user-with-passport', 'APIController@loginUserWithPassport');



    // Update the stock via a third-party API / 3rd-party API (an inventory/stock management system like Uniware Cloud Inventory Control, ...) (using cURL) (POST)    // Here, we're using a third party to handle our stock/inventory management i.e. we don't handle our stock/inventory management ourselves    // API Endpoint:    POST http://127.0.0.1:8000/api/update-stock    // The user must send this 'Authorization' HTTP Header value i.e. Bearer Access Token with their HTTP Request: 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFtaXQgR3VwdGEiLCJpYXQiOjE1MTYyMzkwMjJ9.cNrgi6Sso9wvs4GlJmFnA4IqJY4o2QEcKXgshJTjfNg'    // https://www.youtube.com/watch?v=RQu9mPtTZ94&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=20
    Route::post('update-stock', 'APIController@updateStock');

    // Webhook: Update the stock by giving this API endpoint to a third-party inventory/stock management system (like Uniware Cloud Inventory Control, ...) to access to update our stock (POST)    // Here, the third-party stock/inventory management system (Webhook) accesses our API endpoint only when there's a stock update on their end (the stock/inventory management system's end) to update our stock on our end in our database    // API Endpoint:    POST http://127.0.0.1:8000/api/update-stock-with-webhook    // The user must send this 'Authorization' HTTP Header value i.e. Bearer Access Token with their HTTP Request: 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFtaXQgR3VwdGEiLCJpYXQiOjE1MTYyMzkwMjJ9.cNrgi6Sso9wvs4GlJmFnA4IqJY4o2QEcKXgshJTjfNg'    // https://www.youtube.com/watch?v=Bj1CaqMWI1c&list=PLLUtELdNs2Za4up75dHyaSaMTp0VemrfE&index=21
    Route::post('update-stock-with-webhook', 'APIController@updateStockWithWebhook');
});